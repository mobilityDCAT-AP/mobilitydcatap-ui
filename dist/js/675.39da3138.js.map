{"version":3,"file":"js/675.39da3138.js","mappings":"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","sources":["webpack://mobilitydcatap-ui/./node_modules/canonicalize/lib/canonicalize.js","webpack://mobilitydcatap-ui/./node_modules/http-link-header/lib/link.js","webpack://mobilitydcatap-ui/./node_modules/rdf-data-factory/index.js","webpack://mobilitydcatap-ui/./node_modules/rdf-data-factory/lib/BlankNode.js","webpack://mobilitydcatap-ui/./node_modules/rdf-data-factory/lib/DataFactory.js","webpack://mobilitydcatap-ui/./node_modules/rdf-data-factory/lib/DefaultGraph.js","webpack://mobilitydcatap-ui/./node_modules/rdf-data-factory/lib/Literal.js","webpack://mobilitydcatap-ui/./node_modules/rdf-data-factory/lib/NamedNode.js","webpack://mobilitydcatap-ui/./node_modules/rdf-data-factory/lib/Quad.js","webpack://mobilitydcatap-ui/./node_modules/rdf-data-factory/lib/Variable.js","webpack://mobilitydcatap-ui/./node_modules/relative-to-absolute-iri/index.js","webpack://mobilitydcatap-ui/./node_modules/relative-to-absolute-iri/lib/Resolve.js"],"sourcesContent":["/* jshint esversion: 6 */\n/* jslint node: true */\n'use strict';\n\nmodule.exports = function serialize (object) {\n  if (object === null || typeof object !== 'object' || object.toJSON != null) {\n    return JSON.stringify(object);\n  }\n\n  if (Array.isArray(object)) {\n    return '[' + object.reduce((t, cv, ci) => {\n      const comma = ci === 0 ? '' : ',';\n      const value = cv === undefined || typeof cv === 'symbol' ? null : cv;\n      return t + comma + serialize(value);\n    }, '') + ']';\n  }\n\n  return '{' + Object.keys(object).sort().reduce((t, cv, ci) => {\n    if (object[cv] === undefined ||\n        typeof object[cv] === 'symbol') {\n      return t;\n    }\n    const comma = t.length === 0 ? '' : ',';\n    return t + comma + serialize(cv) + ':' + serialize(object[cv]);\n  }, '') + '}';\n};\n","'use strict'\n\nvar COMPATIBLE_ENCODING_PATTERN = /^utf-?8|ascii|utf-?16-?le|ucs-?2|base-?64|latin-?1$/i\nvar WS_TRIM_PATTERN = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g\nvar WS_CHAR_PATTERN = /\\s|\\uFEFF|\\xA0/\nvar WS_FOLD_PATTERN = /\\r?\\n[\\x20\\x09]+/g\nvar DELIMITER_PATTERN = /[;,\"]/\nvar WS_DELIMITER_PATTERN = /[;,\"]|\\s/\n\n/**\n * Token character pattern\n * @type {RegExp}\n * @see https://tools.ietf.org/html/rfc7230#section-3.2.6\n */\nvar TOKEN_PATTERN = /^[!#$%&'*+\\-\\.^_`|~\\da-zA-Z]+$/\n\nvar STATE = {\n  IDLE: 1 << 0,\n  URI: 1 << 1,\n  ATTR: 1 << 2,\n}\n\nfunction trim( value ) {\n  return value.replace( WS_TRIM_PATTERN, '' )\n}\n\nfunction hasWhitespace( value ) {\n  return WS_CHAR_PATTERN.test( value )\n}\n\nfunction skipWhitespace( value, offset ) {\n  while( hasWhitespace( value[offset] ) ) {\n    offset++\n  }\n  return offset\n}\n\nfunction needsQuotes( value ) {\n  return WS_DELIMITER_PATTERN.test( value ) ||\n    !TOKEN_PATTERN.test( value )\n}\n\n/**\n * Shallow compares two objects to check if their properties match.\n * @param {object} object1 First object to compare.\n * @param {object} object2 Second object to compare.\n * @returns {boolean} Do the objects have matching properties.\n */\nfunction shallowCompareObjects( object1, object2 ) {\n  return (\n    Object.keys( object1 ).length === Object.keys( object2 ).length &&\n    Object.keys( object1 ).every(\n      ( key ) => key in object2 && object1[ key ] === object2[ key ]\n    )\n  );\n}\n\nclass Link {\n\n  /**\n   * Link\n   * @constructor\n   * @param {String} [value]\n   * @returns {Link}\n   */\n  constructor( value ) {\n\n    /** @type {Array} URI references */\n    this.refs = []\n\n    if( value ) {\n      this.parse( value )\n    }\n\n  }\n\n  /**\n   * Get refs with given relation type\n   * @param {String} value\n   * @returns {Array<Object>}\n   */\n  rel( value ) {\n\n    var links = []\n    var type = value.toLowerCase()\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( typeof this.refs[ i ].rel === 'string' && this.refs[ i ].rel.toLowerCase() === type ) {\n        links.push( this.refs[ i ] )\n      }\n    }\n\n    return links\n\n  }\n\n  /**\n   * Get refs where given attribute has a given value\n   * @param {String} attr\n   * @param {String} value\n   * @returns {Array<Object>}\n   */\n  get( attr, value ) {\n\n    attr = attr.toLowerCase()\n    value = value.toLowerCase()\n\n    var links = []\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( typeof this.refs[ i ][ attr ] === 'string' && this.refs[ i ][ attr ].toLowerCase() === value ) {\n        links.push( this.refs[ i ] )\n      }\n    }\n\n    return links\n\n  }\n\n  /** Sets a reference. */\n  set( link ) {\n    this.refs.push( link )\n    return this\n  }\n\n  /**\n   * Sets a reference if a reference with similar properties isnâ€™t already set.\n   */\n  setUnique( link ) {\n\n    if( !this.refs.some(( ref ) => shallowCompareObjects( ref, link )) ) {\n      this.refs.push( link )\n    }\n\n    return this\n\n  }\n\n  has( attr, value ) {\n\n    attr = attr.toLowerCase()\n    value = value.toLowerCase()\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( typeof this.refs[ i ][ attr ] === 'string' && this.refs[ i ][ attr ].toLowerCase() === value ) {\n        return true\n      }\n    }\n\n    return false\n\n  }\n\n  parse( value, offset ) {\n\n    offset = offset || 0\n    value = offset ? value.slice( offset ) : value\n\n    // Trim & unfold folded lines\n    value = trim( value ).replace( WS_FOLD_PATTERN, '' )\n\n    var state = STATE.IDLE\n    var length = value.length\n    var offset = 0\n    var ref = null\n\n    while( offset < length ) {\n      if( state === STATE.IDLE ) {\n        if( hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        } else if( value[offset] === '<' ) {\n          if( ref != null ) {\n            ref.rel != null ?\n              this.refs.push( ...Link.expandRelations( ref ) ) :\n              this.refs.push( ref )\n          }\n          var end = value.indexOf( '>', offset )\n          if( end === -1 ) throw new Error( 'Expected end of URI delimiter at offset ' + offset )\n          ref = { uri: value.slice( offset + 1, end ) }\n          // this.refs.push( ref )\n          offset = end\n          state = STATE.URI\n        } else {\n          throw new Error( 'Unexpected character \"' + value[offset] + '\" at offset ' + offset )\n        }\n        offset++\n      } else if( state === STATE.URI ) {\n        if( hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        } else if( value[offset] === ';' ) {\n          state = STATE.ATTR\n          offset++\n        } else if( value[offset] === ',' ) {\n          state = STATE.IDLE\n          offset++\n        } else {\n          throw new Error( 'Unexpected character \"' + value[offset] + '\" at offset ' + offset )\n        }\n      } else if( state === STATE.ATTR ) {\n        if( value[offset] ===';' || hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        }\n        var end = value.indexOf( '=', offset )\n        if( end === -1 ) end = value.indexOf( ';', offset )\n        if( end === -1 ) end = value.length\n        var attr = trim( value.slice( offset, end ) ).toLowerCase()\n        var attrValue = ''\n        offset = end + 1\n        offset = skipWhitespace( value, offset )\n        if( value[offset] === '\"' ) {\n          offset++\n          while( offset < length ) {\n            if( value[offset] === '\"' ) {\n              offset++; break\n            }\n            if( value[offset] === '\\\\' ) {\n              offset++\n            }\n            attrValue += value[offset]\n            offset++\n          }\n        } else {\n          var end = offset + 1\n          while( !DELIMITER_PATTERN.test( value[end] ) && end < length ) {\n            end++\n          }\n          attrValue = value.slice( offset, end )\n          offset = end\n        }\n        if( ref[ attr ] && Link.isSingleOccurenceAttr( attr ) ) {\n          // Ignore multiples of attributes which may only appear once\n        } else if( attr[ attr.length - 1 ] === '*' ) {\n          ref[ attr ] = Link.parseExtendedValue( attrValue )\n        } else {\n          attrValue = attr === 'type' ?\n            attrValue.toLowerCase() : attrValue\n          if( ref[ attr ] != null ) {\n            if( Array.isArray( ref[ attr ] ) ) {\n              ref[ attr ].push( attrValue )\n            } else {\n              ref[ attr ] = [ ref[ attr ], attrValue ]\n            }\n          } else {\n            ref[ attr ] = attrValue\n          }\n        }\n        switch( value[offset] ) {\n          case ',': state = STATE.IDLE; break\n          case ';': state = STATE.ATTR; break\n        }\n        offset++\n      } else {\n        throw new Error( 'Unknown parser state \"' + state + '\"' )\n      }\n    }\n\n    if( ref != null ) {\n      ref.rel != null ?\n        this.refs.push( ...Link.expandRelations( ref ) ) :\n        this.refs.push( ref )\n    }\n\n    ref = null\n\n    return this\n\n  }\n\n  toString() {\n\n    var refs = []\n    var link = ''\n    var ref = null\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      ref = this.refs[i]\n      link = Object.keys( this.refs[i] ).reduce( function( link, attr ) {\n        if( attr === 'uri' ) return link\n        return link + '; ' + Link.formatAttribute( attr, ref[ attr ] )\n      }, '<' + ref.uri + '>' )\n      refs.push( link )\n    }\n\n    return refs.join( ', ' )\n\n  }\n\n}\n\n/**\n * Determines whether an encoding can be\n * natively handled with a `Buffer`\n * @param {String} value\n * @returns {Boolean}\n */\nLink.isCompatibleEncoding = function( value ) {\n  return COMPATIBLE_ENCODING_PATTERN.test( value )\n}\n\nLink.parse = function( value, offset ) {\n  return new Link().parse( value, offset )\n}\n\nLink.isSingleOccurenceAttr = function( attr ) {\n  return attr === 'rel' || attr === 'type' || attr === 'media' ||\n    attr === 'title' || attr === 'title*'\n}\n\nLink.isTokenAttr = function( attr ) {\n  return attr === 'rel' || attr === 'type' || attr === 'anchor'\n}\n\nLink.escapeQuotes = function( value ) {\n  return value.replace( /\"/g, '\\\\\"' )\n}\n\nLink.expandRelations = function( ref ) {\n  var rels = ref.rel.split( ' ' )\n  return rels.map( function( rel ) {\n    var value = Object.assign( {}, ref )\n    value.rel = rel\n    return value\n  })\n}\n\n/**\n * Parses an extended value and attempts to decode it\n * @internal\n * @param {String} value\n * @return {Object}\n */\nLink.parseExtendedValue = function( value ) {\n  var parts = /([^']+)?(?:'([^']*)')?(.+)/.exec( value )\n  return {\n    language: parts[2].toLowerCase(),\n    encoding: Link.isCompatibleEncoding( parts[1] ) ?\n      null : parts[1].toLowerCase(),\n    value: Link.isCompatibleEncoding( parts[1] ) ?\n      decodeURIComponent( parts[3] ) : parts[3]\n  }\n}\n\n/**\n * Format a given extended attribute and it's value\n * @param {String} attr\n * @param {Object} data\n * @return {String}\n */\nLink.formatExtendedAttribute = function( attr, data ) {\n\n  var encoding = ( data.encoding || 'utf-8' ).toUpperCase()\n  var language = data.language || 'en'\n\n  var encodedValue = ''\n\n  if( Buffer.isBuffer( data.value ) && Link.isCompatibleEncoding( encoding ) ) {\n    encodedValue = data.value.toString( encoding )\n  } else if( Buffer.isBuffer( data.value ) ) {\n    encodedValue = data.value.toString( 'hex' )\n      .replace( /[0-9a-f]{2}/gi, '%$1' )\n  } else {\n    encodedValue = encodeURIComponent( data.value )\n  }\n\n  return attr + '=' + encoding + '\\'' +\n    language + '\\'' + encodedValue\n\n}\n\n/**\n * Format a given attribute and it's value\n * @param {String} attr\n * @param {String|Object} value\n * @return {String}\n */\nLink.formatAttribute = function( attr, value ) {\n\n  if( Array.isArray( value ) ) {\n    return value.map(( item ) => {\n      return Link.formatAttribute( attr, item )\n    }).join( '; ' )\n  }\n\n  if( attr[ attr.length - 1 ] === '*' || typeof value !== 'string' ) {\n    return Link.formatExtendedAttribute( attr, value )\n  }\n\n  if( Link.isTokenAttr( attr ) ) {\n    value = needsQuotes( value ) ?\n      '\"' + Link.escapeQuotes( value ) + '\"' :\n      Link.escapeQuotes( value )\n  } else if( needsQuotes( value ) ) {\n    value = encodeURIComponent( value )\n    // We don't need to escape <SP> <,> <;> within quotes\n    value = value\n      .replace( /%20/g, ' ' )\n      .replace( /%2C/g, ',' )\n      .replace( /%3B/g, ';' )\n\n    value = '\"' + value + '\"'\n  }\n\n  return attr + '=' + value\n\n}\n\nmodule.exports = Link\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/BlankNode\"), exports);\n__exportStar(require(\"./lib/DataFactory\"), exports);\n__exportStar(require(\"./lib/DefaultGraph\"), exports);\n__exportStar(require(\"./lib/Literal\"), exports);\n__exportStar(require(\"./lib/NamedNode\"), exports);\n__exportStar(require(\"./lib/Quad\"), exports);\n__exportStar(require(\"./lib/Variable\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BlankNode = void 0;\n/**\n * A term that represents an RDF blank node with a label.\n */\nclass BlankNode {\n    constructor(value) {\n        this.termType = 'BlankNode';\n        this.value = value;\n    }\n    equals(other) {\n        return !!other && other.termType === 'BlankNode' && other.value === this.value;\n    }\n}\nexports.BlankNode = BlankNode;\n//# sourceMappingURL=BlankNode.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DataFactory = void 0;\nconst BlankNode_1 = require(\"./BlankNode\");\nconst DefaultGraph_1 = require(\"./DefaultGraph\");\nconst Literal_1 = require(\"./Literal\");\nconst NamedNode_1 = require(\"./NamedNode\");\nconst Quad_1 = require(\"./Quad\");\nconst Variable_1 = require(\"./Variable\");\nlet dataFactoryCounter = 0;\n/**\n * A factory for instantiating RDF terms and quads.\n */\nclass DataFactory {\n    constructor(options) {\n        this.blankNodeCounter = 0;\n        options = options || {};\n        this.blankNodePrefix = options.blankNodePrefix || `df_${dataFactoryCounter++}_`;\n    }\n    /**\n     * @param value The IRI for the named node.\n     * @return A new instance of NamedNode.\n     * @see NamedNode\n     */\n    namedNode(value) {\n        return new NamedNode_1.NamedNode(value);\n    }\n    /**\n     * @param value The optional blank node identifier.\n     * @return A new instance of BlankNode.\n     *         If the `value` parameter is undefined a new identifier\n     *         for the blank node is generated for each call.\n     * @see BlankNode\n     */\n    blankNode(value) {\n        return new BlankNode_1.BlankNode(value || `${this.blankNodePrefix}${this.blankNodeCounter++}`);\n    }\n    /**\n     * @param value              The literal value.\n     * @param languageOrDatatype The optional language or datatype.\n     *                           If `languageOrDatatype` is a NamedNode,\n     *                           then it is used for the value of `NamedNode.datatype`.\n     *                           Otherwise `languageOrDatatype` is used for the value\n     *                           of `NamedNode.language`.\n     * @return A new instance of Literal.\n     * @see Literal\n     */\n    literal(value, languageOrDatatype) {\n        return new Literal_1.Literal(value, languageOrDatatype);\n    }\n    /**\n     * This method is optional.\n     * @param value The variable name\n     * @return A new instance of Variable.\n     * @see Variable\n     */\n    variable(value) {\n        return new Variable_1.Variable(value);\n    }\n    /**\n     * @return An instance of DefaultGraph.\n     */\n    defaultGraph() {\n        return DefaultGraph_1.DefaultGraph.INSTANCE;\n    }\n    /**\n     * @param subject   The quad subject term.\n     * @param predicate The quad predicate term.\n     * @param object    The quad object term.\n     * @param graph     The quad graph term.\n     * @return A new instance of Quad.\n     * @see Quad\n     */\n    quad(subject, predicate, object, graph) {\n        return new Quad_1.Quad(subject, predicate, object, graph || this.defaultGraph());\n    }\n    /**\n     * Create a deep copy of the given term using this data factory.\n     * @param original An RDF term.\n     * @return A deep copy of the given term.\n     */\n    fromTerm(original) {\n        // TODO: remove nasty any casts when this TS bug has been fixed:\n        //  https://github.com/microsoft/TypeScript/issues/26933\n        switch (original.termType) {\n            case 'NamedNode':\n                return this.namedNode(original.value);\n            case 'BlankNode':\n                return this.blankNode(original.value);\n            case 'Literal':\n                if (original.language) {\n                    return this.literal(original.value, original.language);\n                }\n                if (!original.datatype.equals(Literal_1.Literal.XSD_STRING)) {\n                    return this.literal(original.value, this.fromTerm(original.datatype));\n                }\n                return this.literal(original.value);\n            case 'Variable':\n                return this.variable(original.value);\n            case 'DefaultGraph':\n                return this.defaultGraph();\n            case 'Quad':\n                return this.quad(this.fromTerm(original.subject), this.fromTerm(original.predicate), this.fromTerm(original.object), this.fromTerm(original.graph));\n        }\n    }\n    /**\n     * Create a deep copy of the given quad using this data factory.\n     * @param original An RDF quad.\n     * @return A deep copy of the given quad.\n     */\n    fromQuad(original) {\n        return this.fromTerm(original);\n    }\n    /**\n     * Reset the internal blank node counter.\n     */\n    resetBlankNodeCounter() {\n        this.blankNodeCounter = 0;\n    }\n}\nexports.DataFactory = DataFactory;\n//# sourceMappingURL=DataFactory.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultGraph = void 0;\n/**\n * A singleton term instance that represents the default graph.\n * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.\n */\nclass DefaultGraph {\n    constructor() {\n        this.termType = 'DefaultGraph';\n        this.value = '';\n        // Private constructor\n    }\n    equals(other) {\n        return !!other && other.termType === 'DefaultGraph';\n    }\n}\nexports.DefaultGraph = DefaultGraph;\nDefaultGraph.INSTANCE = new DefaultGraph();\n//# sourceMappingURL=DefaultGraph.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Literal = void 0;\nconst NamedNode_1 = require(\"./NamedNode\");\n/**\n * A term that represents an RDF literal, containing a string with an optional language tag or datatype.\n */\nclass Literal {\n    constructor(value, languageOrDatatype) {\n        this.termType = 'Literal';\n        this.value = value;\n        if (typeof languageOrDatatype === 'string') {\n            this.language = languageOrDatatype;\n            this.datatype = Literal.RDF_LANGUAGE_STRING;\n        }\n        else if (languageOrDatatype) {\n            this.language = '';\n            this.datatype = languageOrDatatype;\n        }\n        else {\n            this.language = '';\n            this.datatype = Literal.XSD_STRING;\n        }\n    }\n    equals(other) {\n        return !!other && other.termType === 'Literal' && other.value === this.value &&\n            other.language === this.language && this.datatype.equals(other.datatype);\n    }\n}\nexports.Literal = Literal;\nLiteral.RDF_LANGUAGE_STRING = new NamedNode_1.NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#langString');\nLiteral.XSD_STRING = new NamedNode_1.NamedNode('http://www.w3.org/2001/XMLSchema#string');\n//# sourceMappingURL=Literal.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NamedNode = void 0;\n/**\n * A term that contains an IRI.\n */\nclass NamedNode {\n    constructor(value) {\n        this.termType = 'NamedNode';\n        this.value = value;\n    }\n    equals(other) {\n        return !!other && other.termType === 'NamedNode' && other.value === this.value;\n    }\n}\nexports.NamedNode = NamedNode;\n//# sourceMappingURL=NamedNode.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Quad = void 0;\n/**\n * An instance of DefaultGraph represents the default graph.\n * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.\n */\nclass Quad {\n    constructor(subject, predicate, object, graph) {\n        this.termType = 'Quad';\n        this.value = '';\n        this.subject = subject;\n        this.predicate = predicate;\n        this.object = object;\n        this.graph = graph;\n    }\n    equals(other) {\n        // `|| !other.termType` is for backwards-compatibility with old factories without RDF* support.\n        return !!other && (other.termType === 'Quad' || !other.termType) &&\n            this.subject.equals(other.subject) &&\n            this.predicate.equals(other.predicate) &&\n            this.object.equals(other.object) &&\n            this.graph.equals(other.graph);\n    }\n}\nexports.Quad = Quad;\n//# sourceMappingURL=Quad.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Variable = void 0;\n/**\n * A term that represents a variable.\n */\nclass Variable {\n    constructor(value) {\n        this.termType = 'Variable';\n        this.value = value;\n    }\n    equals(other) {\n        return !!other && other.termType === 'Variable' && other.value === this.value;\n    }\n}\nexports.Variable = Variable;\n//# sourceMappingURL=Variable.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/Resolve\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.removeDotSegmentsOfPath = exports.removeDotSegments = exports.resolve = void 0;\n/**\n * Convert the given relative IRI to an absolute IRI\n * by taking into account the given optional baseIRI.\n *\n * @param {string} relativeIRI The relative IRI to convert to an absolute IRI.\n * @param {string} baseIRI The optional base IRI.\n * @return {string} an absolute IRI.\n */\nfunction resolve(relativeIRI, baseIRI) {\n    baseIRI = baseIRI || '';\n    const baseFragmentPos = baseIRI.indexOf('#');\n    // Ignore any fragments in the base IRI\n    if (baseFragmentPos > 0) {\n        baseIRI = baseIRI.substr(0, baseFragmentPos);\n    }\n    // Convert empty value directly to base IRI\n    if (!relativeIRI.length) {\n        // At this point, the baseIRI MUST be absolute, otherwise we error\n        if (baseIRI.indexOf(':') < 0) {\n            throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);\n        }\n        return baseIRI;\n    }\n    // If the value starts with a query character, concat directly (but strip the existing query)\n    if (relativeIRI.startsWith('?')) {\n        const baseQueryPos = baseIRI.indexOf('?');\n        if (baseQueryPos > 0) {\n            baseIRI = baseIRI.substr(0, baseQueryPos);\n        }\n        return baseIRI + relativeIRI;\n    }\n    // If the value starts with a fragment character, concat directly\n    if (relativeIRI.startsWith('#')) {\n        return baseIRI + relativeIRI;\n    }\n    // Ignore baseIRI if it is empty\n    if (!baseIRI.length) {\n        const relativeColonPos = relativeIRI.indexOf(':');\n        if (relativeColonPos < 0) {\n            throw new Error(`Found invalid relative IRI '${relativeIRI}' for a missing baseIRI`);\n        }\n        return removeDotSegmentsOfPath(relativeIRI, relativeColonPos);\n    }\n    // Ignore baseIRI if the value is absolute\n    const valueColonPos = relativeIRI.indexOf(':');\n    if (valueColonPos >= 0) {\n        return removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n    }\n    // At this point, the baseIRI MUST be absolute, otherwise we error\n    const baseColonPos = baseIRI.indexOf(':');\n    if (baseColonPos < 0) {\n        throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);\n    }\n    const baseIRIScheme = baseIRI.substr(0, baseColonPos + 1);\n    // Inherit the baseIRI scheme if the value starts with '//'\n    if (relativeIRI.indexOf('//') === 0) {\n        return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n    }\n    // Check cases where '://' occurs in the baseIRI, and where there is no '/' after a ':' anymore.\n    let baseSlashAfterColonPos;\n    if (baseIRI.indexOf('//', baseColonPos) === baseColonPos + 1) {\n        // If there is no additional '/' after the '//'.\n        baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 3);\n        if (baseSlashAfterColonPos < 0) {\n            // If something other than a '/' follows the '://', append the value after a '/',\n            // otherwise, prefix the value with only the baseIRI scheme.\n            if (baseIRI.length > baseColonPos + 3) {\n                return baseIRI + '/' + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n            }\n            else {\n                return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n            }\n        }\n    }\n    else {\n        // If there is not even a single '/' after the ':'\n        baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 1);\n        if (baseSlashAfterColonPos < 0) {\n            // If we don't have a '/' after the ':',\n            // prefix the value with only the baseIRI scheme.\n            return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n        }\n    }\n    // If the value starts with a '/', then prefix it with everything before the first effective slash of the base IRI.\n    if (relativeIRI.indexOf('/') === 0) {\n        return baseIRI.substr(0, baseSlashAfterColonPos) + removeDotSegments(relativeIRI);\n    }\n    let baseIRIPath = baseIRI.substr(baseSlashAfterColonPos);\n    const baseIRILastSlashPos = baseIRIPath.lastIndexOf('/');\n    // Ignore everything after the last '/' in the baseIRI path\n    if (baseIRILastSlashPos >= 0 && baseIRILastSlashPos < baseIRIPath.length - 1) {\n        baseIRIPath = baseIRIPath.substr(0, baseIRILastSlashPos + 1);\n        // Also remove the first character of the relative path if it starts with '.' (and not '..' or './')\n        // This change is only allowed if there is something else following the path\n        if (relativeIRI[0] === '.' && relativeIRI[1] !== '.' && relativeIRI[1] !== '/' && relativeIRI[2]) {\n            relativeIRI = relativeIRI.substr(1);\n        }\n    }\n    // Prefix the value with the baseIRI path where\n    relativeIRI = baseIRIPath + relativeIRI;\n    // Remove dot segment from the IRI\n    relativeIRI = removeDotSegments(relativeIRI);\n    // Prefix our transformed value with the part of the baseIRI until the first '/' after the first ':'.\n    return baseIRI.substr(0, baseSlashAfterColonPos) + relativeIRI;\n}\nexports.resolve = resolve;\n/**\n * Remove dot segments from the given path,\n * as described in https://www.ietf.org/rfc/rfc3986.txt (page 32).\n * @param {string} path An IRI path.\n * @return {string} A path, will always start with a '/'.\n */\nfunction removeDotSegments(path) {\n    // Prepare a buffer with segments between each '/.\n    // Each segment represents an array of characters.\n    const segmentBuffers = [];\n    let i = 0;\n    while (i < path.length) {\n        // Remove '/.' or '/..'\n        switch (path[i]) {\n            case '/':\n                if (path[i + 1] === '.') {\n                    if (path[i + 2] === '.') {\n                        // Start a new segment if we find an invalid character after the '.'\n                        if (!isCharacterAllowedAfterRelativePathSegment(path[i + 3])) {\n                            segmentBuffers.push([]);\n                            i++;\n                            break;\n                        }\n                        // Go to parent directory,\n                        // so we remove a parent segment\n                        segmentBuffers.pop();\n                        // Ensure that we end with a slash if there is a trailing '/..'\n                        if (!path[i + 3]) {\n                            segmentBuffers.push([]);\n                        }\n                        i += 3;\n                    }\n                    else {\n                        // Start a new segment if we find an invalid character after the '.'\n                        if (!isCharacterAllowedAfterRelativePathSegment(path[i + 2])) {\n                            segmentBuffers.push([]);\n                            i++;\n                            break;\n                        }\n                        // Ensure that we end with a slash if there is a trailing '/.'\n                        if (!path[i + 2]) {\n                            segmentBuffers.push([]);\n                        }\n                        // Go to the current directory,\n                        // so we do nothing\n                        i += 2;\n                    }\n                }\n                else {\n                    // Start a new segment\n                    segmentBuffers.push([]);\n                    i++;\n                }\n                break;\n            case '#':\n            case '?':\n                // Query and fragment string should be appended unchanged\n                if (!segmentBuffers.length) {\n                    segmentBuffers.push([]);\n                }\n                segmentBuffers[segmentBuffers.length - 1].push(path.substr(i));\n                // Break the while loop\n                i = path.length;\n                break;\n            default:\n                // Not a special character, just append it to our buffer\n                if (!segmentBuffers.length) {\n                    segmentBuffers.push([]);\n                }\n                segmentBuffers[segmentBuffers.length - 1].push(path[i]);\n                i++;\n                break;\n        }\n    }\n    return '/' + segmentBuffers.map((buffer) => buffer.join('')).join('/');\n}\nexports.removeDotSegments = removeDotSegments;\n/**\n * Removes dot segments of the given IRI.\n * @param {string} iri An IRI (or part of IRI).\n * @param {number} colonPosition The position of the first ':' in the IRI.\n * @return {string} The IRI where dot segments were removed.\n */\nfunction removeDotSegmentsOfPath(iri, colonPosition) {\n    // Determine where we should start looking for the first '/' that indicates the start of the path\n    let searchOffset = colonPosition + 1;\n    if (colonPosition >= 0) {\n        if (iri[colonPosition + 1] === '/' && iri[colonPosition + 2] === '/') {\n            searchOffset = colonPosition + 3;\n        }\n    }\n    else {\n        if (iri[0] === '/' && iri[1] === '/') {\n            searchOffset = 2;\n        }\n    }\n    // Determine the path\n    const pathSeparator = iri.indexOf('/', searchOffset);\n    if (pathSeparator < 0) {\n        return iri;\n    }\n    const base = iri.substr(0, pathSeparator);\n    const path = iri.substr(pathSeparator);\n    // Remove dot segments from the path\n    return base + removeDotSegments(path);\n}\nexports.removeDotSegmentsOfPath = removeDotSegmentsOfPath;\nfunction isCharacterAllowedAfterRelativePathSegment(character) {\n    return !character || character === '#' || character === '?' || character === '/';\n}\n//# sourceMappingURL=Resolve.js.map"],"names":["module","exports","serialize","object","toJSON","JSON","stringify","Array","isArray","reduce","t","cv","ci","comma","value","undefined","Object","keys","sort","length","COMPATIBLE_ENCODING_PATTERN","WS_TRIM_PATTERN","WS_CHAR_PATTERN","WS_FOLD_PATTERN","DELIMITER_PATTERN","WS_DELIMITER_PATTERN","TOKEN_PATTERN","STATE","IDLE","URI","ATTR","trim","replace","hasWhitespace","test","skipWhitespace","offset","needsQuotes","shallowCompareObjects","object1","object2","every","key","Link","constructor","this","refs","parse","rel","links","type","toLowerCase","i","push","get","attr","set","link","setUnique","some","ref","has","slice","state","Error","expandRelations","end","indexOf","uri","attrValue","isSingleOccurenceAttr","parseExtendedValue","toString","formatAttribute","join","isCompatibleEncoding","isTokenAttr","escapeQuotes","rels","split","map","assign","parts","exec","language","encoding","decodeURIComponent","formatExtendedAttribute","data","toUpperCase","encodedValue","Buffer","isBuffer","encodeURIComponent","item","__createBinding","create","o","m","k","k2","defineProperty","enumerable","__exportStar","p","prototype","hasOwnProperty","call","BlankNode","termType","equals","other","DataFactory","BlankNode_1","DefaultGraph_1","Literal_1","NamedNode_1","Quad_1","Variable_1","dataFactoryCounter","options","blankNodeCounter","blankNodePrefix","namedNode","NamedNode","blankNode","literal","languageOrDatatype","Literal","variable","Variable","defaultGraph","DefaultGraph","INSTANCE","quad","subject","predicate","graph","Quad","fromTerm","original","datatype","XSD_STRING","fromQuad","resetBlankNodeCounter","RDF_LANGUAGE_STRING","resolve","relativeIRI","baseIRI","baseFragmentPos","substr","startsWith","baseQueryPos","relativeColonPos","removeDotSegmentsOfPath","valueColonPos","baseColonPos","baseIRIScheme","baseSlashAfterColonPos","removeDotSegments","baseIRIPath","baseIRILastSlashPos","lastIndexOf","path","segmentBuffers","isCharacterAllowedAfterRelativePathSegment","pop","buffer","iri","colonPosition","searchOffset","pathSeparator","base","character"],"sourceRoot":""}